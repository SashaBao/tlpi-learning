# chapter-7

## 7-1

**修改程序清单 7-1 中的程序（free_and_sbrk.c），在每次执行 malloc()后打印出 program break 的当前值。指定一个较小的内存分配尺寸来运行该程序。这将证明 malloc()不会在每次被调用时都调用 sbrk()来调整 program break 的位置，而是周期性地分配大块内存，并从中将小片内存返回给调用者。**

我在输入./7-1 50 10240 2的时候，发现program break会在很多次分配中保持不变，但是终究是会改变的。原因就如同书中所说：
> 如果在空闲内存列表中根本找不到足够大的空闲内存块，那么 malloc()会调用 sbrk()以分配更多的内存。为减少对 sbrk()的调用次数，malloc()并未只是严格按所需字节数来分配内存，而是以更大幅度（以虚拟内存页大小的数倍）来增加 program break，并将超出部分置于空闲内存列表。

只有在当前空闲列表中找不到足够大的块，才会去调用sbrk，而且一分配就分配很多。这点可以从输出中看出来，从0x559286170000到0x559286193000。

而当我输入./7-1 10 1000 2的时候，发现program break从始至终没有变过。而当我输入./7-1 10000 1000 2，也就是加大数量的时候，program break是会发生变化的，只不过需要分配的次数是要比./7-1 50 10240 2多的。

这里有个犯蠢的地方，一开始program break没变化我以为是我程序写的问题，然后用gdb去调试，然后就各种报错。后来才发现命令行参数是要通过set args传递的。。。

## 7-2

**（高级）实现 malloc()和 free()。**

csapp写过了，虽然写的根本不认真。但如果真的要完全实现难度感觉太高，日后有时间再写吧。
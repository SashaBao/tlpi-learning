# chapter 6

## 6-1

**编译程序清单 6-1 中的程序（mem_segments.c），使用 ls -l 命令显示可执行文件的大小。虽然该程序包含一个大约 10MB 的数组，但可执行文件大小要远小于此，为什么？**

根据书p94：
> 将经过初始化的全局变量和静态变量与未经初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间.

## 6-2

**编写一个程序，观察当使用 longjmp()函数跳转到一个已经返回的函数时会发生什么？**

我采用了书p109的方式写了代码，但是当我通过gcc -o 6-2 6-2.c再./6-2之后运行的结果是无事发生，就是正常输出，最后也没有报错，让我比较震惊。

后来我发现当我调整编译时候的优化选项到O1的时候，在正常输出后就报了段错误；而当我把优化选项调整到O2乃至O3的时候出现的结果是：

```plain text
x() first call setjump!
x() returns
y() starts to call longjmp
y() call longjmp successfully!
x() first call setjump!
x() returns
y() starts to call longjmp
y() call longjmp successfully!
x() first call setjump!
x() returns
...无线循环
段错误
```

我通过管道结合| wc -l统计了行数，发现O2O3情况下有123054行之多。

根据书中：
> 如果幸运的话，程序会一死（crash）了之。然而，取决于栈的状态，也可能会引起调用与返回间的死循环，而程序好像真地从一个当前并未执行的函数中返回了。

看来我是碰到第二种情况了，但我不知道为什么是在优化情况下才会出现这种情况。在不优化的情况下是能够正常结束的。

这个以后再探索吧。

## 6-3

**使用 getenv()函数、putenv()函数，必要时可直接修改 environ，来实现 setenv()函数和 unsetenv()函数。此处的 unsetenv()函数应检查是否对环境变量进行了多次定义，如果是多次定义则将移除对该变量的所有定义（glibc 版本的unsetenv()函数实现了这一功能）。**

完成该题的时候，我起初并没有直接修改environ，只使用了getenv和putenv。因为我认为getenv和putenv是会直接影响environ的，所以无需修改。当然我也没错，只不过我有些地方没思考清楚。果然题目的提升绝对不会是多余的。

environon所指向的字符串是存放在main函数栈帧当中的，也就是说，我们是**不能**用free去free掉这些内存的？而之所以我先前的测试成功了，是因为我unsetenv的本身就是我通过setenv创建的，所以这些字符串被分配在堆上，是可以用free的。

在实现思想上，我很朴素地运用了一个被删除后面全部元素顶上地思想。不过由于要操控二级指针，也debug了一些时间，希望自己以后能多多熟练。这里理论上是可以通过双指针进行优化的，但我懒了（不是）。

有个犯病的地方，可能sizeof写习惯了，我在获取字符串长度的时候也使用了sizeof，导致报错，应该用strlen。

一个memcpy的注意事项：

```c
memcpy(p + nameSize, "=", 1);//cant be '='
```

memcpy的第二个参数必须得是一个指针，所以无法使用单引号，因为char其实是个整型。但是"="中包含了两个字符，包括结束符，这时指定第三个参数即可。
